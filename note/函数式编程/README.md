## 函数式编程学习

个人理解：函数式编程是一个编程思想，通过 `函数` 将表达包裹起来，同时减少不必要的封装

```
吐槽两句：曾经也看过好几次函数curry的文章，但是每次都是看完就忘。
现在回顾，根本原因还是不了解纯函数的意义，包括幂等性等一系列概念。
因此，还是有必要经过系统的学习，才能彻底理解函数式编程的思想。
以上是本人的一些理解，如有不足，欢迎指正
```

纯函数：即相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用。

```js
// 典型的几个例子
var numberA = 1
function add (x) {
  return x + numberA
}
add(1) // 2
numberA = 2
add(1) // 3
// 上面这个函数，只要修改了numberA的值，函数的结果就会发生改变，因此不能称之为纯函数

function add2 (x) {
  var numberB = 1
  return x + numberB
}
add2(1) // 2
// 上面这个函数，numberB被声明在函数内部，只要输入相同的值，总是能得到相同的结果，可以被称之为纯函数
```

纯函数带来的好处：不依赖于系统状态(system state)，减少认知负荷(cognitive load)

什么是函数的副作用：副作用是在计算结果的过程中，系统状态的一种变化，或者与外部世界进行的可观察的交互。

文章补了一句：只要是跟函数外部环境发生的交互就都是副作用

从定义上来说，纯函数必须要能够根据相同的输入返回相同的输出；如果函数需要跟外部事物打交道，那么就无法保证这一点了

纯函数的特点：
  1. 可缓存性
  2. 可移植性／自文档化（Portable / Self-Documenting）
  3. 可测试性（Testable）
  4. 合理性（Reasonable）：这块还有点懵逼，结合后面的代码再看几次
  5. 并行代码

### 函数柯里化

curyy的意义：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数

你可以一次性地调用 curry 函数，也可以每次只传一个参数分多次调用。

```js
// 最经典的代码
// 实现一个add函数
function add(x) {
  return function(y) {
    return x + y
  }
}

var r = add(1)(2) // 3
```

通用函数柯里化的方法

```js
// 设计思路(个人分析)
// 将普通函数，转化成柯里化函数，是一个收集参数的过程，需要利用到的特性有：函数的闭包，浅拷贝，函数的arguments等等
// 第一步：我们需要创建一个纯函数，这个函数接受一个参数，接受的这个参数，就是我们最后需要转化的这个函数，并且允许他通过如下方式调用
curry(function(x, y) {
  return x + y
})

function curry (fn, receiveArgs) {
  // 收集递归的参数，如果没有，就生成一个新数组
  const args = receiveArgs || []
  // 获取函数的参数的长度
  const fnLength = fn.length
  // 返回一个新函数，这个函数接受剩余的参数
  return function (...rest) {
    // 解构收集所有的数组
    const _args = [...args, ...rest]
    // 判断参数的长度是否等于 fn 所需要的参数的长度，如果满足，则执行函数，如果不是则继续返回一个函数等待接收
    return _args.length < fnLength ? curry(fn, _args) : fn(..._args)
  }
}
```

最后：补充一个经典面试题

> 实现一个柯里化函数，可以无限调用 add 函数，而不需要我们显示声明参数的个数


### 代码组合(compose)


